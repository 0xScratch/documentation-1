import React, {useEffect, useRef} from 'react';
import {GlobalContextData, EvmNetworkConfig, useGlobalContext} from '../contexts/GlobalContext';

interface DynamicCodeProps {
  targets: Targets,
  children: React.ReactNode
}

export type Targets = Record<string, ((State) => string)>

/**
 * A syntax-highlighted code block with dynamic text. Nextra typically performs all syntax highlighting on the
 * server side, so we can't simply generate text in a syntax highlighting component. This component works around
 * the problem by finding and replacing specific tokens in an already-highlighted code block with new
 * caller-specified values.
 *
 * @param targets Map of find/replace targets. Each key represents a token in the code block to find and replace.
 *                The replacement string is generated by applying the corresponding function to the current state.
 *                This function has powerful capabilities, as it can read keys from the state and format them, etc.
 *                Note: at the moment, each key must be a complete syntax-highlighted unit of the formatted code
 *                (the complete `innerText` of an HTML element). This behavior could be generalized in the future.
 * @param children The element to which the find/replace targets are applied. You should typically provide a code block
 *                 like ```javascript myJavascriptCode() ```
 */
export default function DynamicCode ({ targets, children }) {
  const context: GlobalContextData = useGlobalContext();
  const state = new DynamicCodeRenderingContext(context.keyValueStore, context.networkConfig)

  const divRef = useRef();
  const targetRefs = useRef();
  // Find the corresponding token from the DOM
  useEffect(() => {
    if (divRef.current && !targetRefs.current) {
      let tokens = []
      for (let [target, replacement] of Object.entries(targets)) {
        console.log(`target: ${target}`)

        // TODO: may need to find more than one
        // note: this explicitly filters out entire lines and only finds spans within lines
        // to preserve highlighting
        const token = [...divRef.current.querySelectorAll('code span')].find((el) => el.innerText === target && el.className != "line");
        if (token !== undefined) {
          tokens.push( { token, target, replacement });
        }
      }
      targetRefs.current = tokens
    }

    for (let {token, replacement} of targetRefs.current) {
      token.innerText = replacement(state);
    }
  }, [state])

  return <>
    <div ref={divRef} style={{ marginTop: '1.5rem' }}>{children}</div>
  </>
}

/**
 * A projection of the GlobalContextData to a subset of properties useful for rendering text.
 * This type is often the argument to functions that render strings on the page.
 * The properties intentionally have short names to make it efficient to write rendering functions.
 * (It's not clear this is a good decision.)
 *
 * TODO: this type needs a better name.
 */
export class DynamicCodeRenderingContext {
  // The global key-value store
  kv: Record<string, string>
  public evmConfig: EvmNetworkConfig | undefined;

  constructor(kv: Record<string, string>, evmConfig: EvmNetworkConfig | undefined) {
    this.kv = kv;
    this.evmConfig = evmConfig;
  }

  // Get the value of key from kv, or return a default value if the key's value is undefined.
  public get(key: string, orElse?: string): string {
    return this.kv[key] !== undefined ? this.kv[key] : orElse;
  }
}
