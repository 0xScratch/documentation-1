import Input from "../../components/Input";
import Arg from "../../components/Arg";
import { InputFormats } from "../../utils/InputFormat";
import Example from "../../components/Example";
import Examples from "../../components/Examples";
import DynamicCode from "../../components/DynamicCode";
import { Tab, Tabs } from "nextra-theme-docs";

# Update Price Feeds

Update the on-chain price feeds using the provided `update_data`, which contains serialized and signed price update data from Pyth Network.
This function updates the on-chain price if the provided update is more recent than the current on-chain price.
Otherwise, the provided update will be ignored.
The function call will succeed even if the update is ignored.

You can retrieve the latest price `update_data` for a given set of price feeds from the price service API.
By default, the data is returned as a base64-encoded string that you must deserialize into a vector of bytes before calling this method.

This function requires the caller to pay a fee to perform the update.
The required fee for a given set of updates can be computed by passing them to [get_update_fee](get-update-fee).

Reverts if the required fee is not paid, or the `update_data` is incorrectly signed or formatted.

<div className="mt-6 overflow-x-auto">

| Argument                                                                     | Input                                                        | Description                                                                     |
| ---------------------------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------- |
| <Arg required={true} type="&PythState">pyth_state</Arg>                      | <Input id="pyth_state" format={InputFormats.ByteArray} />    | The Pyth state object.                                                          |
| <Arg required={true} type=" HotPotatoVector<PriceInfo>,">price_updates</Arg> | <Input id="price_updates" format={InputFormats.BigInt}/>     | vector of authenticated price updates                                           |
| <Arg required={true} type=" &mut PriceInfoObject">price_info_object</Arg>    | <Input id="price_info_object" format={InputFormats.BigInt}/> | PriceInfoObject is a shared Sui object containing the price feed to be updated. |
| <Arg required={true} type=" Coin<SUI>">fee</Arg>                             | <Input id="fee" format={InputFormats.BigInt}/>               | Fee coins.                                                                      |
| <Arg required={true} type=" &Clock">clock</Arg>                              | <Input id="clock" format={InputFormats.BigInt}/>             | clock is a Sui shared object used to tell time and record timestamps            |

</div>

# Warning: do not hardcode price feed updates in your contract

`update_single_price_feed` is meant to be called in a chain of programmable transactions, rather than hardcoded in a contract. This is because when a Sui contract upgrades, the upgraded version lives at a different address. When this happens the previous callsite gets bricked, or becomes un-callable. It is up to the user to use the correct call-site (we also have a helper function for finding the latest call-site given the Pyth state object ID, which is unchanged between upgrades).

<Examples>
  <Example
    keyValues={{
      update_data: async (ctx) =>
        JSON.stringify(
          Array.from(
            Buffer.from(
              (await ctx.getLatestPriceFeed("Crypto.BTC/USD")).vaa,
              "base64"
            )
          )
        ),
      fee: async (ctx) => {
        let vaa = (await ctx.getLatestPriceFeed("Crypto.BTC/USD")).vaa;
        return await ctx.getEthUpdateFee([vaa]);
      },
    }}
    Example
    TBA
  />
</Examples>
